# first_review

# Открытие файлов
Утилита открывыет только тексты с расширением *.txt.

# Файл train.py
В train доступны 5 функций:
    1) --input-dir - путь к директории, в которой лежит коллекция документов. 
            Если данный аргумент не задан, считается, что тексты вводятся из stdin.
            Остановка потока достигается путем ввода "~stop".
    2) --model - путь к файлу, в который сохраняется модель.
    3) --lc - необязательный аргумент. Приводить тексты к lowercase.
    4) --help - выводит список команд в консоль

Пример ввода команды:
    1) --input-dir . --model model.txt
    2) --lc --input-dir /home/.../text.txt --model /home/.../model.txt

Схема работы:
    1) получили команду:
            а) если "--lc" написано, то ставим флаг lower, чтобы потом это учесть
            б) если написано "--input-dir .", то получаем путь в папку, где находится утилита 
            в) если путь в папку указан, то в list txt сохранили все названия файлов, которые заканчиваются на "txt";
            г) если путь не указан, то ставим флаг flag
            д) в model записал путь в файл, куда запишется полученная модель;
    2) создали diction, в котором будет храниться наша модель. Храниться так: dict[dict[list]] , 
            где первый dict будет хранить первое слово из пары и второй dict. Второй dict будет хранить второе слово из 
            пары и количество раз, которое программа встретила в тексте эту пару при своем обходе.
    3) если указан путь до документов, то: 
            попадаем в цикл, в котором мы посетим все файлы, названия которых указаны в list'е txt. 
                а) открываем файл, начинаем считывать строки. Если строка состоит из '\n', то пропускаем её.
                б) запускаем функцию processing, которая вернет нам словарь, в котором уже есть обработанная строка.
                    Функция processing будет описана далее.
       если путь до документов не указан, то:
            попадаем в цикл, в котором будем считывать строки из потока и передавать их в функцию processing. 
            Выход из цикла обеспечивается путем ввода: "~stop"
    4) открываем файл, в который запишем нашу модель в таком виде:
                            "Word_1"  "Word_2"  "Частота встречи этой пары в тексте"
    5) в 80-той строчке ограничение на то, что если пара встретилась одни раз, то записывать ее не будем.  
            
Функция processing(lines, dictions, lowers), где lines - сторка с текстом, dictions - наша модель, lowers - метка,
                        которая показывает, нужно ли приводить к нижнему регистру.
Схема работы:
    1) приводим все символы к нижнему регистру, если lowers == 1;
    2) избавляемся от пробелов/ знаков препинания;
    3) записываем все слова в строке в лист;
    4) обходим весь лист, исключая последнее слово, т.к. после него никакое слово не идет;
    5) обозначаем первое и второе слово в паре;
    6) если в diction первое слово есть, то 
            если второе слово есть, то увеличиваем частоту на 1;
            если второго слова нет, то добавляем второе слово и ставим частоту 1;
       если в diction второго слова нет, то просто добавляем первое и второе слово в соответствующие словари
            с частотой равной 1 
    7) возвращаем словарь
    
# Файл generate.py
В generate доступны 4 функции:
    1) --help - выводит список команд в консоль;
    2) --model - путь к файлу, из которого загружается модель;
    3) --seed - Начальное слово. Если не указано, выбирается слово случайно из всех слов (не учитывая частоты);
    4) --length - длина генерируемой последовательности;
    
Пример ввода команды:
    1) --model /home/.../model.txt --length 10 --seed example
    2) --model model.txt -- length 40
    
Схема работы:
    1) считывается команда
    2) записывается путь, длина последоватьльности и начальное слово, если оно есть, если его нет, то выбираем случайное
    3) загружаем словарь, считывая строку, соответственно добавляя в словарь первое/ второе слово и частоту.
            Схема хранения модели такая же как и в "train".
            Одновременно заполняем лист first_word, в котором будут храниться все первые слова из пар;
    4) если пользователь не ввел начальное слово, то рандомно его выбираем из всех первых слов;
    5) создаем new_text, в котором будет последовательность слов. Добавляем в нее seed; 
    6) заходим в цикл от 0 до length (длину последовательности);
    7) создаем list_next_word, в котором будут храниться все вторые слова первого слова; 
            создаем list frequency, в котором будут хрпниться частоту слов соответствующие list_next_word;
            создаем number, в котором будет храниться суммарная частота всех слов в list_next_word;
    8) если бывшего второго слова, нынешнего первого слова нет в списке первых слов, то берем случайное слово из 
            первых слов;
    9) заполняем то, что создали в пункте 6);
    10) рандомно, с учетом частотности выбираем слово из list_next_word и добавляем его в new_text;
    11) печатаем все элементы new_text.
    
    